# Copyright 2025 The Pigweed Authors
#
# Licensed under the Apache License, Version 2.0 (the "License"); you may not
# use this file except in compliance with the License. You may obtain a copy of
# the License at
#
#     https://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
# WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
# License for the specific language governing permissions and limitations under
# the License.
"""
A self-contained Bazel aspect to generate compile_commands.json fragments.

NOTE: This functionality may eventually belong in rules_cc. See b/437157251
"""

load("@rules_cc//cc/common:cc_common.bzl", "cc_common")
load("@rules_cc//cc/common:cc_info.bzl", "CcInfo")

CompileCommandsFragmentInfo = provider(
    "Provides the depset of compile command fragment files.",
    fields = {
        "fragments": "A depset of compile_commands.json fragment files.",
    },
)

def _get_compile_commands(ctx, target, cc_toolchain, feature_configuration, target_srcs):
    """Reconstructs the compile command for each source file in a target."""
    commands = []
    compilation_context = target[CcInfo].compilation_context

    compile_variables = cc_common.create_compile_variables(
        feature_configuration = feature_configuration,
        cc_toolchain = cc_toolchain,
        user_compile_flags = ctx.fragments.cpp.cxxopts + ctx.fragments.cpp.copts,
    )
    base_argv = list(cc_common.get_memory_inefficient_command_line(
        feature_configuration = feature_configuration,
        action_name = "c++-compile",
        variables = compile_variables,
    ))

    compiler_exec = cc_common.get_tool_for_action(
        feature_configuration = feature_configuration,
        action_name = "c++-compile",
    )

    includes_and_defines = []
    for p in compilation_context.quote_includes.to_list():
        includes_and_defines.extend(["-iquote", p])
    for p in compilation_context.includes.to_list():
        includes_and_defines.extend(["-I", p])
    for p in compilation_context.system_includes.to_list():
        includes_and_defines.extend(["-isystem", p])
    for d in compilation_context.defines.to_list():
        includes_and_defines.append("-D" + d)

    for src in target_srcs:
        full_argv = [compiler_exec] + base_argv + includes_and_defines
        full_argv.extend(["-c", src.path])
        full_argv.extend(["-o", src.path + ".o"])

        commands.append(struct(
            directory = "__WORKSPACE_ROOT__",
            file = src.path,
            arguments = full_argv,
        ))

    return commands

def _compile_commands_aspect_impl(target, ctx):
    """Generates a compile_commands.json fragment for a single target."""
    # The `required_providers` attribute on the aspect definition below ensures
    # this implementation only runs on targets that provide CcInfo.

    cc_toolchain = ctx.toolchains["@bazel_tools//tools/cpp:toolchain_type"].cc
    feature_configuration = cc_common.configure_features(
        ctx = ctx,
        cc_toolchain = cc_toolchain,
    )

    srcs = []
    if hasattr(ctx.rule.attr, "srcs"):
        for src in ctx.rule.attr.srcs:
            srcs.extend(src.files.to_list())
    if hasattr(ctx.rule.attr, "hdrs"):
        for hdr in ctx.rule.attr.hdrs:
            srcs.extend(hdr.files.to_list())

    compilable_srcs = [
        s
        for s in srcs
        if s.extension in ["c", "cc", "cpp", "h", "hh", "hpp"]
    ]

    if not compilable_srcs:
        return [CompileCommandsFragmentInfo(fragments = depset())]

    commands = _get_compile_commands(ctx, target, cc_toolchain, feature_configuration, compilable_srcs)

    # Create a JSON fragment file for this specific target, including the
    # platform name to make it unique. We also add a unique suffix
    # to distinguish these fragments from files generated by other tools.
    platform_fragment = ctx.bin_dir.path.split("/")[1]
    fragment_file = ctx.actions.declare_file(
        ctx.label.name + "." + platform_fragment + ".pw_aspect.compile_commands.json",
    )
    ctx.actions.write(
        output = fragment_file,
        content = json.encode(commands),
    )

    dep_fragments = [
        dep[CompileCommandsFragmentInfo].fragments
        for dep in ctx.rule.attr.deps
        if CompileCommandsFragmentInfo in dep
    ]

    transitive_fragments = depset(
        direct = [fragment_file],
        transitive = dep_fragments,
    )

    return [
        CompileCommandsFragmentInfo(fragments = transitive_fragments),
        OutputGroupInfo(compile_commands_fragments = transitive_fragments),
    ]

compile_commands_aspect = aspect(
    implementation = _compile_commands_aspect_impl,
    attr_aspects = ["deps"],
    fragments = ["cpp"],
    toolchains = ["@bazel_tools//tools/cpp:toolchain_type"],
    required_providers = [CcInfo],
)

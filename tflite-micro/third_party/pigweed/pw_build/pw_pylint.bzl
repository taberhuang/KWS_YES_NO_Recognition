# Copyright 2025 The Pigweed Authors
#
# Licensed under the Apache License, Version 2.0 (the "License"); you may not
# use this file except in compliance with the License. You may obtain a copy of
# the License at
#
#     https://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
# WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
# License for the specific language governing permissions and limitations under
# the License.

"""Aspect for running Pylint on py_* targets."""

load("@rules_python//python:py_info.bzl", RulesPythonPyInfo = "PyInfo")

def _extract_import_dir(import_):
    # Remove first parent from the directory
    if "/" in import_:
        # "_main/path/to/package" -> "path/to/package"
        return import_.split("/", 1)[-1]
    else:
        # "_main" -> ""
        return ""

def _pylint_aspect_impl(target, ctx):
    # We check for providers here because we can't rely on `required_providers`;
    # see comment at the bottom of this file.
    if RulesPythonPyInfo not in target and PyInfo not in target:
        return []

    if not hasattr(ctx.rule.files, "srcs"):
        return []

    direct_srcs = []
    for src in ctx.rule.files.srcs:
        if src.basename.startswith("rules_python_entry_point_"):
            # Python file auto-generated by py_console_script_binary; should not
            # be subject to linting.
            continue
        direct_srcs.append(src)
    if not direct_srcs:
        return []

    # Support both Starlark and legacy native PyInfo providers.
    _PyInfo = RulesPythonPyInfo if RulesPythonPyInfo in target else PyInfo

    # pylint is designed to be run from a Python environment in which the linted
    # modules are already installed, but in Bazel such an environment does not
    # exist. Build up the PYTHONPATH to so that all imports are successfully
    # found.
    #
    # TODO: b/248343713 - Refactor this to use rules_python's get_imports helper
    # (perhaps as part of upstreaming this to rules_python).
    python_path = [
        # Other direct srcs of the current build target which are plain .py
        # files will be found at paths relative to the execroot.
        ".",
        # Other direct srcs of the current build target which are generated
        # files will be found in the bindir.
        ctx.expand_make_variables("bindir_for_pythonpath", "$(BINDIR)", ctx.var),
    ]
    for path in target[_PyInfo].imports.to_list():
        if "/_virtual_imports" in path:
            # Proto generated code. (The leading / distinguishes this from
            # pw_py_importable_runfile, handled next.)
            python_path.append(
                ctx.expand_make_variables(
                    "proto_virtual_imports",
                    "$(BINDIR)/" + _extract_import_dir(path),
                    ctx.var,
                ),
            )
        elif "_virtual_imports" in path:
            if "+" in path:
                # Super-special case: pw_py_importable_runfile in an external
                # repository. See https://pwbug.dev/248343713#comment10 and
                # following.
                python_path.append(
                    ctx.expand_make_variables(
                        "external_repo_importable_runfile_virtual_imports",
                        "$(BINDIR)/external/" + path,
                        ctx.var,
                    ),
                )
            else:
                # pw_py_importable_runfile in the same repository follows the
                # pattern of proto generated code.
                python_path.append(
                    ctx.expand_make_variables(
                        "same_repo_importable_runfile_virtual_imports",
                        "$(BINDIR)/" + _extract_import_dir(path),
                        ctx.var,
                    ),
                )
        elif "+" in path:
            # Non-generated external Python dependency.
            python_path.append("external/" + path)
        else:
            # Non-generated Python dependency within this repository.
            python_path.append(_extract_import_dir(path))

    outputs = []
    for src in direct_srcs:
        output_file = ctx.actions.declare_file(ctx.label.name + "." + src.path + ".pylint.txt")
        outputs.append(output_file)

        args = ctx.actions.args()
        args.add("--rcfile", ctx.file._pylintrc.path)

        # Prevent pylint from escaping the sandbox and caching the results of
        # past runs.  Weirdly, the pylint docs don't discuss what the persisted
        # data is actually used for; https://stackoverflow.com/q/25475327
        # suggests it's for reporting improvements in some global "score".
        args.add("--persistent", "False")

        # Write the output to file, and also print it (colorized) to the
        # console. (pylint only prints any output if at least one check fails.)
        args.add("--output-format", "text:" + output_file.path + ",colorized")

        # TODO: b/248343713 - See
        # https://pigweed.dev/get_started/analysis.html#known-limitations
        args.add("--disable=wrong-import-order")
        args.add(src)

        ctx.actions.run(
            executable = ctx.executable._pylint,
            inputs = depset(
                direct = direct_srcs + ctx.files._pylintrc,
                transitive = [target[_PyInfo].transitive_sources],
            ),
            outputs = [output_file],
            arguments = [args],
            mnemonic = "Pylint",
            progress_message = "Pylinting " + str(ctx.label) + " (" + src.basename + ")",
            env = {"PYTHONPATH": ctx.configuration.host_path_separator.join(python_path)},
        )

    return [OutputGroupInfo(report = depset(direct = outputs))]

pylint_aspect = aspect(
    implementation = _pylint_aspect_impl,
    # We don't actually need to propagate up the graph.
    attr_aspects = [],
    attrs = {
        "_pylint": attr.label(
            default = Label("@pigweed//pw_build:pylint"),
            executable = True,
            cfg = "exec",
        ),
        "_pylintrc": attr.label(
            default = Label("@pigweed//pw_build:pylintrc"),
            allow_single_file = True,
        ),
    },
    # Ideally, here we would restrict the aspect to rules which provide PyInfo.
    # But there's a subtlety here: to avoid being filtered out, rules not only
    # need to provide the Provider, but also _advertise_ that they do so.  The
    # builtin PyInfo has been advertised as provided by the Python rules since
    # Bazel 8.0.0
    # (https://github.com/bazelbuild/bazel/commit/910e5769224b5d06392eec1abd684612642ca4aa).
    # However, the rules_python rules have only advertised that they provide
    # this aspect since rules_python 1.5.0
    # (https://github.com/bazel-contrib/rules_python/commit/cc46fb26d629b9e440371861f031cb2a85fd9c55).
    # So, we cannot uncomment the line below until we upgrade to rules_python
    # 1.5.0.
    # required_providers = [[PyInfo], [RulesPythonPyInfo]],
)

# Copyright 2024 The Pigweed Authors
#
# Licensed under the Apache License, Version 2.0 (the "License"); you may not
# use this file except in compliance with the License. You may obtain a copy of
# the License at
#
#     https://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
# WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
# License for the specific language governing permissions and limitations under
# the License.

##########
# Copied with a handful of small changes from:
# https://cs.opensource.google/fuchsia/fuchsia/+/main:build/bazel_sdk/bazel_rules_fuchsia/fuchsia/workspace/fuchsia_products_repository.bzl
##########

"""Defines a repository rule for generating SDK companion image targets."""

def _fuchsia_products_repository_impl(ctx):
    if (bool(ctx.attr.cipd_bin) and bool(ctx.attr.ensure_file)) == bool(ctx.attr.metadata_file):
        fail("Either cipd_bin and ensure_file must be defined or metadata_file, but not both.")

    product_bundles_manifest = ctx.attr.metadata_file
    if ctx.attr.cipd_bin and ctx.attr.ensure_file:
        _fetch_cipd_contents(ctx, ctx.attr.cipd_bin, ctx.attr.ensure_file)
        product_bundles_manifest = "product_bundles.json"

    product_bundles_metadata = json.decode(ctx.read(product_bundles_manifest))
    ctx.file("BUILD.bazel", """# DO NOT MODIFY.
# AUTOGENERATED BY `fuchsia_products_repository.bzl`.

load("@rules_fuchsia//fuchsia:defs.bzl", "fuchsia_remote_product_bundle")

""" + "\n\n".join([
        """
fuchsia_remote_product_bundle(
    name = "%s",
    transfer_url = "%s",
    product_version = "%s",
    visibility = ["//visibility:public"],
)
""".strip() % (pb["name"], pb["transfer_manifest_url"], pb["product_version"])
        for pb in product_bundles_metadata
    ]))

fuchsia_products_repository = repository_rule(
    doc = """Initalizes targets for SDK companion images.

Example Usage:
```
# Initializing the repo:
load("@rules_fuchsia//fuchsia:deps.bzl", "fuchsia_products_repository")

fuchsia_products_repository(
    name = "fuchsia_products",
    cipd_bin = "@cipd_tool//:cipd",
    ensure_file = "//manifests:product_bundles.ensure",
)

# Examining the generated targest:
#   $ bazel query '@fuchsia_products//... except attr("tags", "manual", @fuchsia_products//...)'

# Using the targets:
#   $ bazel run @fuchsia_products//:core.x64.emu -- --headless
#   $ bazel run @fuchsia_products//:core.vim3.flash
""",
    implementation = _fuchsia_products_repository_impl,
    attrs = {
        "cipd_bin": attr.label(
            doc = "The cipd binary that will be used to download the companion image metadata.",
        ),
        "ensure_file": attr.label(
            doc = "A cipd ensure file to use to download the companion image metadata.",
        ),
        "metadata_file": attr.label(
            doc = "A label referencing product_bundles.json.",
            allow_single_file = True,
        ),
    },
)

##########
# Copied verbatim from https://cs.opensource.google/fuchsia/fuchsia/+/main:build/bazel_sdk/bazel_rules_fuchsia/fuchsia/workspace/utils.bzl
##########
def _fetch_cipd_contents(ctx, cipd_bin, cipd_ensure_file, root = "."):
    """Fetches the contents of a cipd bucket and places them in the root.

    Args:
      ctx: A repository_ctx instance.

      cipd_bin: Either a Path object, or a relative or absolute path string which
          points to a cipd binary. If absolute, the path is  returned as is. If
          relative, it is resolved relative to the main workspace's directory.

      cipd_ensure_file: Either a Path object, or a relative or absolute path string which
          points to a cipd binary. If absolute, the path is  returned as is. If
          relative, it is resolved relative to the main workspace's directory.

      root: A path to where the contents will be installed.
    """
    result = ctx.execute(
        [
            ctx.path(cipd_bin),
            "ensure",
            "-ensure-file",
            ctx.path(cipd_ensure_file),
            "-root",
            root,
            "-max-threads=0",
        ],
    )
    if result.return_code != 0:
        fail("Unable to download cipd content for {}\n{}".format(cipd_ensure_file, result.stderr))
